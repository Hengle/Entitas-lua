---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 29801.
--- DateTime: 2018/12/4 10:21
---
local Signal = require("entitas.Signal")
local Bag = require("entitas.Bag")
local utils = require("entitas.util")
local Group = require("entitas.Group")
local Entity = require("entitas.Entity")
---@class _Context
---@field _reusableEntities Bag
local Context = {
    _entities = {},
    _groups = {},
    _debug = false,
    totalComponents = 0,
    name = '',
    __property = nil,
    __getproperty= nil,
    __setproperty = nil,
}

Context.__index = Context
function Context.new(...)
    local tb = setmetatable({}, Context)
    tb:ctor(...)
    return tb
end


---@private
function Context:ctor(components, totalComponents, debug, startCreationIndex)
    startCreationIndex = startCreationIndex or 0
    Context.instance = self
    self.onGroupCreated = Signal.new()
    self.onEntityCreated = Signal.new()
    self.onEntityDestroyed = Signal.new()
    self.onEntityWillBeDestroyed = Signal.new()
    self._entityIndices = {}
    self._reusableEntities = Bag.new()
    self._reusableEntitiesCache = {}
    self._debug = debug
    self._componentsEnum = components
    self._totalComponents = totalComponents
    self.id = startCreationIndex
    self._groupsForIndex = {}
    self._cachedUpdateGroupsComponentAddedOrRemoved =  function(...) self:updateGroupsComponentAddedOrRemoved(...)  end
    self._cachedUpdateGroupsComponentReplaced = function(...) self:updateGroupsComponentReplaced(...)  end
    self._cachedOnEntityReleased = function(...) self:onEntityReleased(...) end
    Context.componentsEnum = components
    Context.totalComponents = totalComponents
end

---@return Entity
function Context:createEntity(name)
    ---@type _Entity
    local entity
    if self._reusableEntities:size() > 0 then
        entity = self._reusableEntities:removeLast()
        --print("GetEntity From Pool", entity)
    else
        entity = Entity.new(self._componentsEnum, self._totalComponents)
    end
    entity._isEnabled = true
    entity.name = name
    self.id = self.id + 1
    entity.id = self.id
    entity:addRef()
    self._entities[entity.id] = entity
    self._entitiesCache = nil
    entity.onComponentAdded:add(self._cachedUpdateGroupsComponentAddedOrRemoved)
    entity.onComponentRemoved:add(self._cachedUpdateGroupsComponentAddedOrRemoved)
    entity.onComponentReplaced:add(self._cachedUpdateGroupsComponentReplaced)
    entity.onEntityReleased:add(self._cachedOnEntityReleased)

    local onEntityCreated = self.onEntityCreated
    if (onEntityCreated.active) then
        onEntityCreated:dispatch(self. entity)
    end
    return entity
end

---@param entity _Entity
function Context:destroyEntity(entity)
    if (not(self._entities[entity.id])) then
        error("Could not destroy entity~")
    end
    self._entities[entity.id] = nil
    self._entitiesCache = nil
    local onEntityWillBeDestroyed = self.onEntityWillBeDestroyed
    if (onEntityWillBeDestroyed.active) then
        onEntityWillBeDestroyed:dispatch(self. entity)
    end

    entity:_destroy()
    --print(entity._refCount, " !!!!!!!!!!!!!!!!!!!")
    local onEntityDestroyed = self.onEntityDestroyed
    if (onEntityDestroyed.active) then
        onEntityDestroyed:dispatch(self. entity)
    end

    if (entity._refCount == 1) then
        entity.onEntityReleased:remove(self._cachedOnEntityReleased)
        self._reusableEntities:add(entity)
    else
        self._reusableEntitiesCache[entity.id] = entity
    end
    entity:release()
end

---@private
function Context:destroyAllEntities()
    local entities = self:getEntities()
    local len = #entities
    for i= 1, len  do
        self:destroyEntity(entities[i])
    end
end

---@private
function Context: hasEntity(entity)
    return self._entities[entity.id]
end

---@private
function Context:getEntities(matcher)
    if (matcher) then
        return self:getGroup(matcher).getEntities()
    else
        if (self._entitiesCache == nil) then
            local entities = self._entities
            local keys = utils.keys(entities)
            local length = #keys
            self._entitiesCache = {}
            local entitiesCache = self._entitiesCache
            for i = 1, length do
                entitiesCache[i] = entities[keys[i]]
            end
        end
        return self._entitiesCache
    end
end


function Context:createSystem(system)
    local tb = system.new(self)
    if tb.setContext then
        tb.setContext(tb, self)
    end
    return tb
end

---@return Group
---@param matcher _Matcher
function Context:getGroup(matcher)
    local group
    local matcher_key = matcher:getUniqueKey()
    if ( self._groups[matcher_key]) then
        group = self._groups[matcher_key]
    else
        group = Group.new(matcher)
        self._groups[matcher_key] = group

        local entities = self:getEntities()
        local len = #entities
        for i = 1, len do
            group:handleEntitySilently(entities[i])
        end
        local Indices = matcher:getIndices()
        local inLen = #Indices
        for i = 1 , inLen do
            local index = Indices[i]
            if (self._groupsForIndex[index] == nil) then
                self._groupsForIndex[index] = Bag.new()
            end
            self._groupsForIndex[index]:add(group)
        end

        local onGroupCreated = self.onGroupCreated
        if (onGroupCreated.active) then
            onGroupCreated:dispatch(self. group)
        end
    end

    return group
end

---@private
function Context:updateGroupsComponentAddedOrRemoved  (entity, index, component)
    local groups = self._groupsForIndex[index]
    if (groups ~= nil) then
        local count = groups:size()
        for i = 1, count do
            groups[i]:handleEntity(entity, index, component)
        end
    end
end

---@private
function Context:updateGroupsComponentReplaced(entity, index, previousComponent, newComponent)
    local groups = self._groupsForIndex[index]
    if (groups ~= nil) then
        local len = groups:size()
        for i = 1, len do
            groups[i]:updateEntity(entity, index, previousComponent, newComponent)
        end
    end
end

---@private
---@param entity _Entity
function Context:onEntityReleased(entity)
    if (entity._isEnabled) then
        error("Cannot release entity.")
    end
    entity.onEntityReleased:remove(self._cachedOnEntityReleased)
    self._reusableEntitiesCache[entity.id] = nil
    self._reusableEntities:add(entity)
end

function Context:addEntityIndex(entityIndex)
    if self._entityIndices[entityIndex.comp_index] then
        error(entityIndex.comp_index .. " already has index")
    end
    self._entityIndices[entityIndex.comp_index] = entityIndex
end

function Context:getEntityIndex(comp_index)
    local ret = self._entityIndices[comp_index]
    if ret == nil then
        error(comp_index .. " is not exist")
    end
    return ret
end

---@private
function Context.setPool(system, pool)
    local poolSystem = utils.as(system, 'setPool')
    if (poolSystem ~= nil) then
        poolSystem:setPool(pool)
    end
end


return Context