---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 29801.
--- DateTime: 2018/12/4 10:20
---
---
local Signal = require("entitas.Signal")
local GroupEventType = require("entitas.GroupEventType")
local utils = require("entitas.util")

---@class Group
---@field onEntityAdded Signal
---@field onEntityRemoved Signal
---@field onEntityUpdated Signal
local Group = {
    _entitiesCache = nil,
    _SignalEntityCache = nil,
    _toStringCache = '',
}

Group.__index = Group
function Group.new(...)
    local tb =setmetatable({}, Group)
    tb:ctor(...)
    return tb
end

function Group:ctor(matcher)
    self.onEntityAdded = Signal.new()
    self.onEntityRemoved = Signal.new()
    self.onEntityUpdated = Signal.new()
    self._entities = {}
    self._matcher = matcher
end

function Group:createObserver(eventType)
    eventType = eventType or GroupEventType.OnEntityAdded
    return GroupObserver.new(self, eventType)
end

function Group:handleEntitySilently(entity)
    if (self._matcher:matches(entity)) then
        self:addEntitySilently(entity)
    else
        self:removeEntitySilently(entity)
    end
end

function Group:handleEntity(entity, index, component)
    if (self._matcher:matches(entity)) then
        self:addEntity(entity, index, component)
    else
        self:removeEntity(entity, index, component)
    end
end

function Group:updateEntity(entity, index, previousComponent, newComponent)
    if (self._entities[entity.id ]) then

        local onEntityRemoved= self.onEntityRemoved
        if (onEntityRemoved.active) then
            onEntityRemoved:dispatch(self, entity, index, previousComponent)
        end
        local onEntityAdded= self.onEntityAdded
        if (onEntityAdded.active) then
            onEntityAdded:dispatch(self, entity, index, newComponent)
        end
        local onEntityUpdated= self.onEntityUpdated
        if (onEntityUpdated.active) then
            onEntityUpdated:dispatch(self, entity, index, previousComponent, newComponent)
        end
    end
end

function Group:addEntitySilently(entity)
    if not self._entities[entity.id ] then
        self._entities[entity.id] = entity
        self._entitiesCache = nil
        self._signalEntityCache = nil
        entity:addRef()
        return true
    end
    return false
end

function Group:addEntity(entity, index, component)
    if self:addEntitySilently(entity) then
        local onEntityAdded= self.onEntityAdded
        if (onEntityAdded.active)then
            onEntityAdded:dispatch(self, entity, index, component)
        end
    end
end

function Group:removeEntitySilently(entity)
    if self._entities[entity.id ] then
        self._entities[entity.id] = nil
        self._entitiesCache = nil
        self._signalEntityCache = nil
        entity:release()
        return true
    end
    return false
end

function Group:removeEntity(entity, index, component)
    if self:removeEntitySilently(entity) then
        local onEntityRemoved= self.onEntityRemoved
        if (onEntityRemoved.active)then
            onEntityRemoved:dispatch(self, entity, index, component)
        end
    end
end

function Group:containsEntity(entity)
    return self._entities[entity.id ]
end

---@return Entity[]
function Group:getEntities()
    if (self._entitiesCache == nil) then
        local entities = self._entities
        self._entitiesCache = {}
        local entitiesCache = self._entitiesCache
        local i = 1
        for k, v in pairs(entities) do
            entitiesCache[i] = v
            i = i + 1
        end
    end
    return self._entitiesCache
end

function Group:getSingleEntity()
    if (self._signalEntityCache == nil) then
        local enumerator = utils.keys(self._entities)
        local c = #enumerator
        if (c == 1) then
            self._signalEntityCache = self._entities[enumerator[1]]
        elseif (c == 0) then
            return nil
        else
            error("Single Entity has more Entity")
        end
    end
    return self._signalEntityCache
end

function Group:toString()
    if (self._toStringCache == nil) then
        self._toStringCache = "Group(" .. tostring(self._matcher) .. ")"
    end
    return self._toStringCache
end

return Group